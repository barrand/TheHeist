---
description: Project overview — what The Heist is, how it works, and how the pieces connect
alwaysApply: true
---

# The Heist — Project Overview

A real-time multiplayer heist puzzle game. Players take on roles (mastermind, safe_cracker, hacker, grifter, etc.) and cooperate to complete a scripted scenario by finishing interdependent tasks, finding items, and talking to NPCs.

---

## Architecture

```
Flutter web frontend  ←→  FastAPI backend  ←  Scenario files (markdown/JSON)
        ↑                       ↑                       ↑
   WebSocket (ws://)      REST + WebSocket        Generated by Python
   lib/services/          app/api/                scripts/generators/
   websocket_service.dart websocket.py
```

**Frontend:** Flutter web app at `localhost:8087`. Single-page, WebSocket-driven.  
**Backend:** FastAPI at `localhost:8000`. WebSocket handler is the primary API surface.  
**Scenarios:** Ephemeral — generated on-the-fly by an LLM pipeline when a game starts. Cached as markdown + JSON in `backend/experiences/` but treated as disposable; delete them freely to force regeneration.

---

## How a Game Works

1. Players open the app → land on `landing_page.dart`
2. Host creates a room (gets a 5-letter code). Others join with the code.
3. Everyone selects a role in the lobby (`room_lobby_screen.dart`)
4. Host picks a scenario and hits Start Game
5. Backend checks if the scenario file exists; **generates it on-the-fly** if not (`scenario_generator_service.py`)
6. Backend loads the scenario, initializes `GameState`, and sends `game_started` to each player with their role-specific tasks
7. Game loop: players complete tasks, search rooms for items, talk to NPCs, hand off items to teammates
8. When all required tasks are done the backend broadcasts `game_ended` → everyone sees the win screen

---

## Scenario Pipeline (Generation)

Scripts live in `backend/scripts/`:

```
procedural_generator.py   → build ScenarioGraph (tasks, locations, items, NPCs)
graph_validator_fixer.py  → validate + auto-fix the graph (up to 10 iterations)
json_exporter.py          → write experiences/{scenario}.json
markdown_renderer.py      → write experiences/generated_{scenario}_{n}players.md
validate_scenario.py      → parse markdown, check playability rules
scenario_editor_agent.py  → LLM-powered fix for any remaining critical issues
```

Generated files are cached on disk but are ephemeral — delete them freely to force regeneration. Each unique scenario + role combination produces a different generated file (e.g. `generated_museum_gala_vault_3players.md`).

---

## Key Concepts

| Concept | Description |
|---|---|
| **Scenario** | A heist story with tasks, locations, items, and NPCs. Identified by `scenario_id`. |
| **Task** | A unit of work assigned to a role. Types: `minigame`, `search`, `npc_llm`, `handoff`, `info_share`. |
| **Prerequisites** | Tasks can require other tasks, items, or NPC outcomes to be unlocked. |
| **Item** | A physical object found by searching a location. May be required by a task. |
| **NPC** | A character a player talks to. Conversations are LLM-driven (Gemini). |
| **Outcome** | A named result of completing an NPC task (e.g. `cameras_disabled`). Can unlock other tasks. |
| **Role** | A player archetype. Roles and their codes are in `shared_data/roles.json` and `ROLE_CODES` in `procedural_generator.py`. |

---

## Important File Locations

| What | Where |
|---|---|
| WebSocket game logic | `backend/app/api/websocket.py` |
| Game state model | `backend/app/models/game_state.py` |
| Scenario loading | `backend/app/services/experience_loader.py` |
| On-the-fly generation | `backend/app/services/scenario_generator_service.py` |
| Role definitions | `shared_data/roles.json` |
| Scenario definitions | `shared_data/scenarios.json` |
| Generated experiences | `backend/experiences/generated_*.md` |
| Flutter screens | `frontend/lib/screens/` |
| Flutter WS service | `frontend/lib/services/websocket_service.dart` |
| Design tokens | `frontend/lib/core/theme/` |
| Debug shortcuts | `frontend/lib/core/app_config.dart` → `debugMode` |

---

## E2E Testing

`backend/scripts/e2e_testing/` runs automated bot playthroughs.  
Start manually: `cd backend && E2E_PORT=5555 python3 scripts/e2e_testing/ui_server.py`  
Bots use Gemini to decide actions. Results report WIN / DEADLOCK / TIMEOUT / ERROR.
